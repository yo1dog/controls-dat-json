/* 
 * Usage: node controlsDATXMLtoJSON.js [-min]
 * 
 * Converts the controls.dat XML format into a JSON format with a similar structure.
 * 
 * You can download controls.xml from http://controls.arcadecontrols.com/
 * 
 * Generates /json/controls.json
 * 
 * 
 * !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 * !!         WARNING          !!
 * !!                          !!
 * !! Windows PowerShell Users !!
 * !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 * 
 * You can not use the > operator to write the output JSON to a file as it will be
 * saved with UTF-8-BOM encoding which will make it invalid JSON. Using
 * "| Out-File -Encoding utf8" instead solves this problem.
 */

var xmldoc     = require('xmldoc');
var cliWrapper = require('../helpers/cliWrapper');
var wrapError  = require('../helpers/wrapError');

var usageExampleStr =
  'node controlsDATXMLtoJSON.js [-min]\n' +
  '\n' +
  'bash:\n' +
  'cat controls.xml | node controlsDATXMLtoJSON.js > controls.json\n' +
  '\n' +
  'Windows Command Prompt:\n' +
  'type controls.xml | node controlsDATXMLtoJSON.js > controls.json\n' +
  '\n' +
  '!! Windows PowerShell !!:\n' +
  'cat controls.xml | node controlsDATXMLtoJSON.js | Out-File -Encoding utf8 controls.json';


cliWrapper(usageExampleStr, function controlsDATXMLtoJSON(stdinData) {
  ////////////////////////
  // Entry Point
  ////////////////////////
  
  // parse the data from stdin as XML
  var xmlDoc;
  try {
    xmlDoc = new xmldoc.XmlDocument(stdinData);
  }
  catch(err) {
    throw wrapError(err, 'Error parsing data from stdin as XML.');
  }
  
  // format the controls.dat XML document as a readable object
  var controlsDatObj = convertControlsDatXML(xmlDoc);
  
  return controlsDatObj;
});

function getXMLElemRequiredChild(xmlElem, childName) {
  var childXMLElem = xmlElem.childNamed(childName);
  
  if (!childXMLElem) {
    throw new Error('"' + childName + '" element is missing.');
  }
  
  return childXMLElem;
}
function getXMLElemOptionalChildAttr(xmlElem, childName, attrKey) {
  var childXMLElem = xmlElem.childNamed(childName);
  
  if (!childXMLElem) {
    return null;
  }
  
  var value = childXMLElem.attr[attrKey];
  if (!value) {
    return value;
  }
  
  return value.trim();
}
function getXMLElemOptionalChildVal(xmlElem, childName) {
  var childXMLElem = xmlElem.childNamed(childName);
  
  if (!childXMLElem) {
    return null;
  }
  
  return childXMLElem.val.trim();
}
function getXMLElemRequiredAttr(xmlElem, attrKey) {
  var value = xmlElem.attr[attrKey];
  
  if (typeof value === 'undefined') {
    throw new Error('"' + attrKey + '" attribute is missing.');
  }
  
  value = value.trim();
  
  if (typeof value.length === 0) {
    throw new Error('"' + attrKey + '" attribute is empty.');
  }
  
  return value;
}
function getXMLElemRequiredAttrInt(xmlElem, attrKey) {
  var valueStr = getXMLElemRequiredAttr(xmlElem, attrKey);
  
  if (!(/\-?^[0-9]+$/.test(valueStr))) {
    throw new Error('"' + attrKey + '" attribute is not a valid integer.');
  }
  
  var value = parseInt(valueStr);
  return value;
}
function getXMLElemRequiredAttrIntMin(xmlElem, attrKey, minValue) {
  var value = getXMLElemRequiredAttrInt(xmlElem, attrKey);
  if (value < minValue) {
    throw new Error('"' + attrKey + '" attribute is less than ' + minValue + '.');
  }
  
  return value;
}
function getXMLElemRequiredAttrBool(xmlElem, attrKey) {
  var valueStr = getXMLElemRequiredAttr(xmlElem, attrKey);
  valueStr = valueStr.toLowerCase();
  
  var value;
  if (valueStr === 'true' || valueStr === '1') {
    value = true;
  }
  else if (valueStr === 'false' || valueStr === '0') {
    value = false;
  }
  else {
    throw new Error('"' + attrKey + '" attribute is not a valid boolean.');
  }
  
  return value;
}








function convertControlsDatXML(controlsDatXMLDoc) {
  // first format the controls.dat XML document into an easy-to-use JavaScript object
  var controlsDat = {
    meta : formatMeta(controlsDatXMLDoc),
    games: formatGames(controlsDatXMLDoc)
  };
  
  // now lets do some converting
  // change the description
  controlsDat.meta.description = 'Controls.dat JSON file';
  
  // update the time
  controlsDat.meta.xmlTime = controlsDat.meta.time;
  controlsDat.meta.time    = new Date();
  
  // update the generated by
  controlsDat.meta.xmlGeneratedBy = controlsDat.meta.generatedBy;
  controlsDat.meta.generatedBy    = ''; // set this in the output file if you want
  
  return controlsDat;
}

function formatMeta(controlsDatXMLDoc) {
  var metaXMLElem = getXMLElemRequiredChild(controlsDatXMLDoc, 'meta');
  var meta = formatMetaXMLElem(metaXMLElem);
  
  return meta;
}
function formatMetaXMLElem(metaXMLElem) {
  var date;
  var timeStr = getXMLElemOptionalChildAttr(metaXMLElem, 'time', 'name');
  if (timeStr) {
    date = new Date(timeStr);
    
    if (isNaN(date.getTime())) {
      throw new Error('"time" element\'s "name" attribute is not a valid date.');
    }
  }
  else {
    date = null;
  }
  
  var meta = {
    description: getXMLElemOptionalChildAttr(metaXMLElem, 'description', 'name') || '',
    version    : getXMLElemOptionalChildAttr(metaXMLElem, 'version'    , 'name') || '',
    time       : date,
    generatedBy: getXMLElemOptionalChildAttr(metaXMLElem, 'generatedBy', 'name') || ''
  };
  
  return meta;
}

function formatGames(controlsDatXMLDoc) {
  var gameXMLElems = controlsDatXMLDoc.childrenNamed('game');
  var games = [];
  
  for (var i = 0; i < gameXMLElems.length; ++i) {
    var gameXMLElem = gameXMLElems[i];
    
    var game;
    try {
      game = formatGameXMLElem(gameXMLElem);
    }
    catch(err) {
      throw wrapError(err, 'Error formating game XML element at line ' + (gameXMLElem.line + 1) + ', column ' + (gameXMLElem.column + 1) + '.');
    }
    
    games.push(game);
  }
  
  // make sure there are not multiple games with the same romname
  for (var j = 0; j < games.length - 1; ++j) {
    for (var k = j + 1; k < games.length; ++k) {
      if (games[j].romname === games[k].romname) {
        throw new Error('Multiple games with same romname "' + games[k].romname + '".');
      }
    }
  }
  
  // make sure there is at least 1 game
  if (games.length === 0) {
    throw new Error('No games.');
  }
  
  return games;
}
function formatGameXMLElem(gameXMLElem) {
  var game = {
    romname    : getXMLElemRequiredAttr      (gameXMLElem, 'romname'),
    gamename   : getXMLElemRequiredAttr      (gameXMLElem, 'gamename'),
    numPlayers : getXMLElemRequiredAttrIntMin(gameXMLElem, 'numPlayers' , 1),
    alternating: getXMLElemRequiredAttrBool  (gameXMLElem, 'alternating'),
    mirrored   : getXMLElemRequiredAttrBool  (gameXMLElem, 'mirrored'),
    usesService: getXMLElemRequiredAttrBool  (gameXMLElem, 'usesService'),
    tilt       : getXMLElemRequiredAttrBool  (gameXMLElem, 'tilt'),
    cocktail   : getXMLElemRequiredAttrBool  (gameXMLElem, 'cocktail'),
    miscDetails: getXMLElemOptionalChildVal  (gameXMLElem, 'miscDetails') || '',
    players    : formatGamePlayers(gameXMLElem)
  };
  
  if (game.mirrored && game.players.length > 1) {
    throw new Error('Game is defined as mirrored but multiple players are defined.');
  }
  
  return game;
}

function formatGamePlayers(gameXMLElem) {
  var playerXMLElems = gameXMLElem.childrenNamed('player');
  var players = [];
  
  for (var i = 0; i < playerXMLElems.length; ++i) {
    var playerXMLElem = playerXMLElems[i];
    
    var player;
    try {
      player = formatPlayerXMLElem(playerXMLElem);
    }
    catch(err) {
      throw wrapError(err, 'Error formating player XML element at line ' + (playerXMLElem.line + 1) + ', column ' + (playerXMLElem.column + 1) + '.');
    }
    
    players.push(player);
  }
  
  // sort the players so index 0 is player 1, index 1 is player 2, etc. (assuming there are no gaps)
  players.sort(function(playerA, playerB) {
    return playerA.number - playerB.number;
  });
  
  // check for gaps (ex: players 1, 2, and 4 were defined but not 3, or player 2 was defined but not 1)
  for (var j = 0; j < players.length; ++j) {
    if (players[j].number !== j + 1) {
      throw new Error('Player ' + (j + 1) + ' is missing.');
    }
  }
  
  // make sure there is at least 1 player
  if (players.length === 0) {
    throw new Error('No players.');
  }
  
  return players;
}
function formatPlayerXMLElem(playerXMLElem) {
  var player = {
    number    : getXMLElemRequiredAttrIntMin(playerXMLElem, 'number', 1),
    numButtons: getXMLElemRequiredAttrIntMin(playerXMLElem, 'numButtons', 0),
    controls  : formatPlayerControls(playerXMLElem),
    labels    : formatPlayerLabels(playerXMLElem)
  };
  
  return player;
}

function formatPlayerControls(playerXMLElem) {
  var controlsXMLElem = getXMLElemRequiredChild(playerXMLElem, 'controls');
  var controlXMLElems = controlsXMLElem.children;
  
  var controls = [];
  
  // format controls for each control XML element
  for (var i = 0; i < controlXMLElems.length; ++i) {
   var controlXMLElem = controlXMLElems[i];
    
    var control;
    try {
      control = formatControlXMLElem(controlXMLElem);
    }
    catch(err) {
      throw wrapError(err, 'Error formating control XML element at line ' + (controlXMLElem.line + 1) + ', column ' + (controlXMLElem.column + 1) + '.');
    }
    
    controls.push(control);
  }
  
  return controls;
}

function formatControlXMLElem(controlXMLElem) {
  var control = {
    name     : getXMLElemRequiredAttr(controlXMLElem, 'name'),
    constants: formatControlConstants(controlXMLElem),
    buttons  : formatControlButtons(controlXMLElem)
  };
  
  return control;
}

function formatControlConstants(controlXMLElem) {
  var constantXMLElems = controlXMLElem.childrenNamed('constant');
  var constants = [];
  
  for (var i = 0; i < constantXMLElems.length; ++i) {
    var constantXMLElem = constantXMLElems[i];
    
    var constant;
    try {
      constant = formatConstantXMLElem(constantXMLElem);
    }
    catch(err) {
      throw wrapError(err, 'Error formating constant XML element at line ' + (constantXMLElem.line + 1) + ', column ' + (constantXMLElem.column + 1) + '.');
    }
    
    constants.push(constant);
  }
  
  return constants;
}
function formatConstantXMLElem(constantXMLElem) {
  return getXMLElemRequiredAttr(constantXMLElem, 'name');
}

function formatControlButtons(controlXMLElem) {
  var buttonXMLElems = controlXMLElem.childrenNamed('button');
  var buttons = [];
  
  for (var i = 0; i < buttonXMLElems.length; ++i) {
    var buttonXMLElem = buttonXMLElems[i];
    
    var button;
    try {
      button = formatButtonXMLElem(buttonXMLElem);
    }
    catch(err) {
      throw wrapError(err, 'Error formating button XML element at line ' + (buttonXMLElem.line + 1) + ', column ' + (buttonXMLElem.column + 1) + '.');
    }
    
    buttons.push(button);
  }
  
  return buttons;
}
function formatButtonXMLElem(buttonXMLElem) {
  return getXMLElemRequiredAttr(buttonXMLElem, 'name');
}

function formatPlayerLabels(playerXMLElem) {
  var labelsXMLElem = getXMLElemRequiredChild(playerXMLElem, 'labels');
  var labelXMLElems = labelsXMLElem.children;
  
  var labels = [];
  
  for (var i = 0; i < labelXMLElems.length; ++i) {
    var labelXMLElem = labelXMLElems[i];
    
    var label;
    try {
      label = formatLabelXMLElem(labelXMLElem);
    }
    catch(err) {
      throw wrapError(err, 'Error formating label XML element at line ' + (labelXMLElem.line + 1) + ', column ' + (labelXMLElem.column + 1) + '.');
    }
    
    labels.push(label);
  }
  
  return labels;
}
function formatLabelXMLElem(labelXMLElem) {
  var label = {
    name : getXMLElemRequiredAttr(labelXMLElem, 'name'),
    value: getXMLElemRequiredAttr(labelXMLElem, 'value')
  };
  
  return label;
}