/* 
 * Usage: node controlsDATXMLtoJSON.js [--min]
 * 
 * Converts the controls.dat XML format into a JSON format with a similar structure.
 * 
 * You can download controls.xml from http://controls.arcadecontrols.com/
 * 
 * Generates /json/controls.json
 * 
 * 
 * !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 * !!         WARNING          !!
 * !!                          !!
 * !! Windows PowerShell Users !!
 * !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 * 
 * You can not use the > operator to write the output JSON to a file as it will be
 * saved with UTF-8-BOM encoding which will make it invalid JSON. Using
 * "| Out-File -Encoding utf8" instead solves this problem.
 */

const xmldoc     = require('xmldoc');
const xmlHelper  = require('../helpers/xmlHelper');
const cliWrapper = require('../helpers/cliWrapper');
const CError     = require('@yo1dog/cerror');

const usageExampleStr =
`node controlsDATXMLtoJSON.js [--min]

bash:
cat controls.xml | node controlsDATXMLtoJSON.js > controls.json

Windows Command Prompt:
type controls.xml | node controlsDATXMLtoJSON.js > controls.json

!! Windows PowerShell !!:
cat controls.xml | node controlsDATXMLtoJSON.js | Out-File -Encoding utf8 controls.json`;


cliWrapper(usageExampleStr, controlsDATXMLtoJSON);
function controlsDATXMLtoJSON(stdinData) {
  ////////////////////////
  // Entry Point
  ////////////////////////
  
  // parse the data from stdin as XML
  let xmlDoc;
  try {
    xmlDoc = new xmldoc.XmlDocument(stdinData);
  }
  catch(err) {
    throw new CError(err, 'Error parsing data from stdin as XML.');
  }
  
  // format the controls.dat XML document as a readable object
  const controlsDatObj = convertControlsDatXML(xmlDoc);
  return controlsDatObj;
}


function convertControlsDatXML(controlsDatXMLDoc) {
  // first format the controls.dat XML document into an easy-to-use JavaScript object
  const controlsDat = {
    meta : formatMeta(controlsDatXMLDoc),
    games: formatGames(controlsDatXMLDoc)
  };
  
  // now lets do some converting
  // change the description
  controlsDat.meta.description = 'Controls.dat JSON file';
  
  // update the time
  controlsDat.meta.xmlTime = controlsDat.meta.time;
  controlsDat.meta.time    = new Date();
  
  // update the generated by
  controlsDat.meta.xmlGeneratedBy = controlsDat.meta.generatedBy;
  controlsDat.meta.generatedBy    = ''; // set this in the output file if you want
  
  return controlsDat;
}

function formatMeta(controlsDatXMLDoc) {
  const metaXMLElem = xmlHelper.getXMLElemRequiredChild(controlsDatXMLDoc, 'meta');
  const meta = formatMetaXMLElem(metaXMLElem);
  
  return meta;
}
function formatMetaXMLElem(metaXMLElem) {
  let date;
  const timeStr = xmlHelper.getXMLElemOptionalChildAttr(metaXMLElem, 'time', 'name');
  if (timeStr) {
    date = new Date(timeStr);
    
    if (isNaN(date.getTime())) {
      throw new Error(`'time' element's 'name' attribute is not a valid date.`);
    }
  }
  else {
    date = null;
  }
  
  const meta = {
    description: xmlHelper.getXMLElemOptionalChildAttr(metaXMLElem, 'description', 'name') || '',
    version    : xmlHelper.getXMLElemOptionalChildAttr(metaXMLElem, 'version'    , 'name') || '',
    time       : date,
    generatedBy: xmlHelper.getXMLElemOptionalChildAttr(metaXMLElem, 'generatedBy', 'name') || ''
  };
  
  return meta;
}

function formatGames(controlsDatXMLDoc) {
  const gameXMLElems = controlsDatXMLDoc.childrenNamed('game');
  
  const games = gameXMLElems.map(gameXMLElem => {
    try {
      return formatGameXMLElem(gameXMLElem);
    }
    catch(err) {
      throw new CError(err, `Error formating game XML element at line ${gameXMLElem.line + 1}, column ${gameXMLElem.column + 1}.`);
    }
  });
  
  // make sure there are not multiple games with the same romname
  for (let j = 0; j < games.length - 1; ++j) {
    for (let k = j + 1; k < games.length; ++k) {
      if (games[j].romname === games[k].romname) {
        throw new Error(`Multiple games with same romname '${games[k].romname}'.`);
      }
    }
  }
  
  // make sure there is at least 1 game
  if (games.length === 0) {
    throw new Error('No games.');
  }
  
  return games;
}
function formatGameXMLElem(gameXMLElem) {
  const game = {
    romname    : xmlHelper.getXMLElemRequiredAttr      (gameXMLElem, 'romname'),
    gamename   : xmlHelper.getXMLElemRequiredAttr      (gameXMLElem, 'gamename'),
    numPlayers : xmlHelper.getXMLElemRequiredAttrIntMin(gameXMLElem, 'numPlayers' , 1),
    alternating: xmlHelper.getXMLElemRequiredAttrBool  (gameXMLElem, 'alternating'),
    mirrored   : xmlHelper.getXMLElemRequiredAttrBool  (gameXMLElem, 'mirrored'),
    usesService: xmlHelper.getXMLElemRequiredAttrBool  (gameXMLElem, 'usesService'),
    tilt       : xmlHelper.getXMLElemRequiredAttrBool  (gameXMLElem, 'tilt'),
    cocktail   : xmlHelper.getXMLElemRequiredAttrBool  (gameXMLElem, 'cocktail'),
    miscDetails: xmlHelper.getXMLElemOptionalChildVal  (gameXMLElem, 'miscDetails') || '',
    players    : formatGamePlayers(gameXMLElem)
  };
  
  if (game.mirrored && game.players.length > 1) {
    throw new Error('Game is defined as mirrored but multiple players are defined.');
  }
  
  return game;
}

function formatGamePlayers(gameXMLElem) {
  const playerXMLElems = gameXMLElem.childrenNamed('player');
  
  const players = playerXMLElems.map(playerXMLElem => {
    try {
      return formatPlayerXMLElem(playerXMLElem);
    }
    catch(err) {
      throw new CError(err, `Error formating player XML element at line ${playerXMLElem.line + 1}, column ${playerXMLElem.column + 1}.`);
    }
  });
  
  // sort the players so index 0 is player 1, index 1 is player 2, etc. (assuming there are no gaps)
  players.sort((playerA, playerB) => playerA.number - playerB.number);
  
  // check for gaps (ex: players 1, 2, and 4 were defined but not 3, or player 2 was defined but not 1)
  for (let j = 0; j < players.length; ++j) {
    if (players[j].number !== j + 1) {
      throw new Error(`Player ${j + 1} is missing.`);
    }
  }
  
  // make sure there is at least 1 player
  if (players.length === 0) {
    throw new Error('No players.');
  }
  
  return players;
}
function formatPlayerXMLElem(playerXMLElem) {
  const player = {
    number    : xmlHelper.getXMLElemRequiredAttrIntMin(playerXMLElem, 'number', 1),
    numButtons: xmlHelper.getXMLElemRequiredAttrIntMin(playerXMLElem, 'numButtons', 0),
    controls  : formatPlayerControls(playerXMLElem),
    labels    : formatPlayerLabels(playerXMLElem)
  };
  
  return player;
}

function formatPlayerControls(playerXMLElem) {
  const controlsXMLElem = xmlHelper.getXMLElemRequiredChild(playerXMLElem, 'controls');
  const controlXMLElems = controlsXMLElem.children;
  
  const controls = controlXMLElems.map(controlXMLElem => {
    try {
      return formatControlXMLElem(controlXMLElem);
    }
    catch(err) {
      throw new CError(err, `Error formating control XML element at line ${controlXMLElem.line + 1}, column ${controlXMLElem.column + 1}.`);
    }
  });
  
  return controls;
}

function formatControlXMLElem(controlXMLElem) {
  const control = {
    name     : xmlHelper.getXMLElemRequiredAttr(controlXMLElem, 'name'),
    constants: formatControlConstants(controlXMLElem),
    buttons  : formatControlButtons(controlXMLElem)
  };
  
  return control;
}

function formatControlConstants(controlXMLElem) {
  const constantXMLElems = controlXMLElem.childrenNamed('constant');
  
  const constants = constantXMLElems.map(constantXMLElem => {
    try {
      return formatConstantXMLElem(constantXMLElem);
    }
    catch(err) {
      throw new CError(err, `Error formating constant XML element at line ${constantXMLElem.line + 1}, column ${constantXMLElem.column + 1}.`);
    }
  });
  
  return constants;
}
function formatConstantXMLElem(constantXMLElem) {
  return xmlHelper.getXMLElemRequiredAttr(constantXMLElem, 'name');
}

function formatControlButtons(controlXMLElem) {
  const buttonXMLElems = controlXMLElem.childrenNamed('button');
  
  const buttons = buttonXMLElems.map(buttonXMLElem => {
    try {
      return formatButtonXMLElem(buttonXMLElem);
    }
    catch(err) {
      throw new CError(err, `Error formating button XML element at line ${buttonXMLElem.line + 1}, column ${buttonXMLElem.column + 1}.`);
    }
  });
  
  return buttons;
}
function formatButtonXMLElem(buttonXMLElem) {
  return xmlHelper.getXMLElemRequiredAttr(buttonXMLElem, 'name');
}

function formatPlayerLabels(playerXMLElem) {
  const labelsXMLElem = xmlHelper.getXMLElemRequiredChild(playerXMLElem, 'labels');
  const labelXMLElems = labelsXMLElem.children;
  
  const labels = labelXMLElems.map(labelXMLElem => {
    try {
      return formatLabelXMLElem(labelXMLElem);
    }
    catch(err) {
      throw new CError(err, `Error formating label XML element at line ${labelXMLElem.line + 1}, column ${labelXMLElem.column + 1}.`);
    }
  });
  
  return labels;
}
function formatLabelXMLElem(labelXMLElem) {
  const label = {
    name : xmlHelper.getXMLElemRequiredAttr(labelXMLElem, 'name'),
    value: xmlHelper.getXMLElemRequiredAttr(labelXMLElem, 'value')
  };
  
  return label;
}